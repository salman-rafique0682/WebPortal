{
  "version": 3,
  "sources": ["../../../../../../node_modules/chartjs-chart-matrix/dist/chartjs-chart-matrix.esm.js"],
  "sourcesContent": ["/*!\n * chartjs-chart-matrix v0.0.0-development\n * https://chartjs-chart-matrix.pages.dev/\n * (c) 2025 Jukka Kurkela\n * Released under the MIT license\n */\nimport { DatasetController, Element } from 'chart.js';\nimport { toTRBLCorners, addRoundedRectPath, isObject } from 'chart.js/helpers';\nvar version = \"0.0.0-development\";\nclass MatrixController extends DatasetController {\n  static id = 'matrix';\n  static version = version;\n  static defaults = {\n    dataElementType: 'matrix',\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height']\n      }\n    }\n  };\n  static overrides = {\n    interaction: {\n      mode: 'nearest',\n      intersect: true\n    },\n    scales: {\n      x: {\n        type: 'linear',\n        offset: true\n      },\n      y: {\n        type: 'linear',\n        reverse: true\n      }\n    }\n  };\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n  update(mode) {\n    const me = this;\n    const meta = me._cachedMeta;\n    me.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n  updateElements(rects, start, count, mode) {\n    const me = this;\n    const reset = mode === 'reset';\n    const {\n      xScale,\n      yScale\n    } = me._cachedMeta;\n    const firstOpts = me.resolveDataElementOptions(start, mode);\n    const sharedOptions = me.getSharedOptions(mode, rects[start], firstOpts);\n    for (let i = start; i < start + count; i++) {\n      const parsed = !reset && me.getParsed(i);\n      const x = reset ? xScale.getBasePixel() : xScale.getPixelForValue(parsed.x);\n      const y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(parsed.y);\n      const options = me.resolveDataElementOptions(i, mode);\n      const {\n        width,\n        height,\n        anchorX,\n        anchorY\n      } = options;\n      const properties = {\n        x: resolveX(anchorX, x, width),\n        y: resolveY(anchorY, y, height),\n        width,\n        height,\n        options\n      };\n      me.updateElement(rects[i], i, properties, mode);\n    }\n    me.updateSharedOptions(sharedOptions, mode);\n  }\n  draw() {\n    const me = this;\n    const data = me.getMeta().data || [];\n    let i, ilen;\n    for (i = 0, ilen = data.length; i < ilen; ++i) {\n      data[i].draw(me._ctx);\n    }\n  }\n}\nfunction resolveX(anchorX, x, width) {\n  if (anchorX === 'left' || anchorX === 'start') {\n    return x;\n  }\n  if (anchorX === 'right' || anchorX === 'end') {\n    return x - width;\n  }\n  return x - width / 2;\n}\nfunction resolveY(anchorY, y, height) {\n  if (anchorY === 'top' || anchorY === 'start') {\n    return y;\n  }\n  if (anchorY === 'bottom' || anchorY === 'end') {\n    return y - height;\n  }\n  return y - height / 2;\n}\n\n/**\n * Helper function to get the bounds of the rect\n * @param {MatrixElement} rect the rect\n * @param {boolean} [useFinalPosition]\n * @return {object} bounds of the rect\n * @private\n */\nfunction getBounds(rect, useFinalPosition) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n  return {\n    left: x,\n    top: y,\n    right: x + width,\n    bottom: y + height\n  };\n}\nfunction limit(value, min, max) {\n  return Math.max(Math.min(value, max), min);\n}\nfunction parseBorderWidth(rect, maxW, maxH) {\n  const value = rect.options.borderWidth;\n  let t, r, b, l;\n  if (isObject(value)) {\n    t = +value.top || 0;\n    r = +value.right || 0;\n    b = +value.bottom || 0;\n    l = +value.left || 0;\n  } else {\n    t = r = b = l = +value || 0;\n  }\n  return {\n    t: limit(t, 0, maxH),\n    r: limit(r, 0, maxW),\n    b: limit(b, 0, maxH),\n    l: limit(l, 0, maxW)\n  };\n}\nfunction boundingRects(rect) {\n  const bounds = getBounds(rect);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(rect, width / 2, height / 2);\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b\n    }\n  };\n}\nfunction inRange(rect, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const bounds = !rect || skipX && skipY ? false : getBounds(rect, useFinalPosition);\n  return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);\n}\nclass MatrixElement extends Element {\n  static id = 'matrix';\n  static defaults = {\n    backgroundColor: undefined,\n    borderColor: undefined,\n    borderWidth: undefined,\n    borderRadius: 0,\n    anchorX: 'center',\n    anchorY: 'center',\n    width: 20,\n    height: 20\n  };\n  constructor(cfg) {\n    super();\n    this.options = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  draw(ctx) {\n    const options = this.options;\n    const {\n      inner,\n      outer\n    } = boundingRects(this);\n    const radius = toTRBLCorners(options.borderRadius);\n    ctx.save();\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRoundedRectPath(ctx, {\n        x: outer.x,\n        y: outer.y,\n        w: outer.w,\n        h: outer.h,\n        radius\n      });\n      addRoundedRectPath(ctx, {\n        x: inner.x,\n        y: inner.y,\n        w: inner.w,\n        h: inner.h,\n        radius\n      });\n      ctx.fillStyle = options.backgroundColor;\n      ctx.fill();\n      ctx.fillStyle = options.borderColor;\n      ctx.fill('evenodd');\n    } else {\n      ctx.beginPath();\n      addRoundedRectPath(ctx, {\n        x: inner.x,\n        y: inner.y,\n        w: inner.w,\n        h: inner.h,\n        radius\n      });\n      ctx.fillStyle = options.backgroundColor;\n      ctx.fill();\n    }\n    ctx.restore();\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n    return {\n      x: x + width / 2,\n      y: y + height / 2\n    };\n  }\n  tooltipPosition() {\n    return this.getCenterPoint();\n  }\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\nexport { MatrixController, MatrixElement };"],
  "mappings": "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",
  "names": []
}
